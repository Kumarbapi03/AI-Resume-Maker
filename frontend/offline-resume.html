<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title data-translation-key="welcome_title">Offline Builder | Technolize</title>
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Lobster&display=swap" rel="stylesheet">
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script>
        // Use window.jspdf = window.jspdf.jsPDF for ES Module compatibility
        window.jsPDF = window.jspdf.jsPDF;
    </script>
    
    <style>
        /* --- General & Body Setup --- */
        :root {
            /* NEW OFFLINE THEME: Darker Blue/Gray for an "in-app, local" feel */
            --primary-lightest: #E0E7EB; /* Light Gray-Blue */
            --primary-light: #8DA9C2;    /* Medium Blue */
            --primary-medium: #4B6B8A;   /* Slate Blue */
            --primary-dark: #37475E;     /* Dark Navy Blue (Main Accent) */
            --secondary-dark: #1F2C3A;   /* Very Dark Blue-Gray */
            --secondary-darkest: #151D26; /* Deepest Blue-Gray (Text) */
            --border-light: #C0CDD4;     /* Lighter gray-blue for borders */
        }
        
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--primary-lightest); /* Changed */
            color: var(--secondary-darkest);
            min-height: 100vh;
            position: relative;
            overflow-x: hidden;
        }

        /* --- START: CSS FOR TOP BAR --- */
        .top-bar {
            width: 100%;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1.5rem 2.5rem; 
            position: relative;
            z-index: 100;
            flex-shrink: 0;
        }

        .logo {
            font-family: 'Lobster', cursive;
            font-size: 1.9rem;
            font-weight: 400;
            color: var(--secondary-darkest);
        }
        
        .language-switcher {
            position: relative;
        }

        .language-btn {
            display: flex;
            align-items: center;
            gap: 6px;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 8px 12px;
            font-family: 'Inter', sans-serif;
            font-size: 0.9rem;
            font-weight: 500;
            background-color: #fcfcfc;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        /* NEW: Changed 'Online Mode' button to reflect 'Offline' status */
        .mode-btn {
            display: flex;
            align-items: center;
            gap: 6px;
            border: 1px solid var(--primary-medium); /* Changed border color */
            border-radius: 8px;
            padding: 8px 12px;
            font-size: 0.9rem;
            font-weight: 60;
            background-color: var(--primary-medium); /* Changed background color */
            color: white;
            cursor: pointer;
            margin-right: 15px;
            transition: all 0.2s ease;
        }
        
        .mode-btn:hover {
            background-color: var(--primary-dark); /* Changed hover color */
            border-color: var(--primary-dark);
        }

        .language-btn:hover,
        .language-btn:focus {
            outline: none;
            border-color: var(--primary-dark);
            box-shadow: 0 0 0 3px rgba(55, 71, 94, 0.1); /* Adjusted shadow color */
        }

        .language-dropdown {
            display: none; 
            position: absolute;
            top: 110%;
            right: 0;
            min-width: 220px;
            background-color: #ffffff;
            border-radius: 12px;
            border: 1px solid #eee;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.1);
            max-height: 300px;
            overflow-y: auto;
            z-index: 110;
        }

        .language-dropdown.show {
            display: block;
        }

        .language-option {
            display: block;
            padding: 10px 16px;
            font-size: 0.95rem;
            color: #333;
            text-decoration: none;
            cursor: pointer;
        }

        .language-option:hover {
            background-color: #f5f5f9;
        }
        
        .language-option.selected {
            font-weight: 600;
            color: var(--primary-dark);
            background-color: #eaf1f6; /* Adjusted selected background color */
        }
        /* --- END: CSS FOR TOP BAR --- */


        .container {
            max-width: 900px;
            margin: 0 auto;
            padding: 0 2rem 2rem;
            display: flex;
            flex-direction: column;
            height: calc(100vh - 85px);
        }

        /* --- 1. Header Section --- */
        .header-content {
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
            margin-bottom: 2rem; 
            transition: all 0.3s ease; 
        }
        
        .header-content.hidden {
            display: none;
        }


        .ai-tag {
            background-color: #ffffff;
            color: var(--primary-medium);
            padding: 6px 12px;
            border-radius: 16px;
            font-size: 0.8rem;
            font-weight: 500;
            margin-bottom: 1rem;
            border: 1px solid var(--border-light);
        }

        .header-content h1 {
            font-size: 3rem;
            font-weight: 700;
            color: var(--secondary-darkest);
            margin-bottom: 0.5rem;
        }

        .subtitle {
            font-size: 1.1rem;
            color: var(--primary-dark);
            max-width: 600px;
            line-height: 1.6;
            margin-bottom: 2rem;
        }

        .create-goal-btn {
            background-color: var(--primary-dark);
            color: white;
            border: none;
            border-radius: 8px;
            padding: 12px 20px;
            font-size: 1rem;
            font-weight: 600;
            font-family: 'Inter', sans-serif;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            box-shadow: 0 4px 14px rgba(55, 71, 94, 0.25); /* Adjusted shadow color */
            transition: all 0.3s ease;
        }
        
        .create-goal-btn:disabled {
            background-color: #aaa;
            cursor: not-allowed;
            opacity: 0.7;
        }

        .create-goal-btn:hover {
            background-color: var(--primary-medium);
            box-shadow: 0 6px 16px rgba(55, 71, 94, 0.3);
            transform: translateY(-2px);
        }
        
        .create-goal-btn:disabled:hover {
            background-color: #aaa;
            box-shadow: 0 4px 14px rgba(55, 71, 94, 0.25);
            transform: none;
        }


        /* --- 2. Chat Display Area --- */
        .chat-display-area {
            display: none; /* Hidden by default */
            flex-direction: column;
            gap: 10px;
            width: 100%;
            flex-grow: 1;
            overflow-y: auto;
            background: #ffffff; 
            border: 1px solid var(--border-light); 
            border-radius: 12px;
            padding: 1.5rem;
            box-shadow: 0 4px 12px rgba(0,0,0,0.05);
        }

        .chat-display-area.visible {
            display: flex;
        }

        .chat-message {
            padding: 10px 16px;
            border-radius: 18px;
            max-width: 80%;
            line-height: 1.5;
            font-size: 0.95rem;
            animation: fadeIn 0.3s ease-out; 
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .bot-message {
            background-color: #eaf1f6; /* Adjusted bot message color */
            color: var(--secondary-darkest); 
            align-self: flex-start;
            display: flex; 
            align-items: center; 
            gap: 10px; 
        }

        .bot-icon {
            width: 28px;
            height: 28px;
            flex-shrink: 0;
            background: var(--primary-dark);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 0.8rem; 
        }
        
        .bot-icon svg {
             width: 16px;
             height: 16px;
             fill: white;
        }

        .bot-message-text {
            flex-grow: 1;
        }

        .user-message {
            background-color: var(--primary-dark); 
            color: white;
            align-self: flex-end;
            margin-left: auto;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .user-icon {
            width: 28px;
            height: 28px;
            flex-shrink: 0;
            background: var(--primary-lightest);
            border: 1px solid var(--primary-dark);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--primary-dark);
            font-size: 0.8rem;
            order: 2;
        }
        
        .user-icon svg {
             width: 16px;
             height: 16px;
             stroke: var(--primary-dark);
             fill: none;
        }

        .user-message-text {
            flex-grow: 1;
            order: 1;
        }

        /* --- Styles for typing indicator --- */
        .typing-indicator {
            padding: 10px 16px;
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .typing-indicator .dot {
            width: 8px;
            height: 8px;
            background-color: #aaa;
            border-radius: 50%;
            animation: pulse 1.2s infinite ease-in-out;
        }
        .typing-indicator .dot:nth-child(2) { animation-delay: 0.2s; }
        .typing-indicator .dot:nth-child(3) { animation-delay: 0.4s; }
        @keyframes pulse {
            0%, 80%, 100% { transform: scale(0.6); opacity: 0.5; }
            40% { transform: scale(1); opacity: 1; }
        }

        /* --- START: CSS FOR OPTIONS --- */
        .options-container {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            align-self: flex-start;
            width: 100%;
            padding: 10px 0 5px 40px;
            animation: fadeIn 0.3s ease-out;
        }
        
        .option-btn {
            background-color: #ffffff;
            border: 1px solid var(--border-light);
            color: var(--primary-dark);
            padding: 8px 14px;
            border-radius: 16px;
            font-size: 0.9rem;
            font-weight: 500;
            font-family: 'Inter', sans-serif;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .option-btn:hover {
            background-color: #eaf1f6; /* Adjusted hover color */
            border-color: var(--primary-medium);
        }
        
        .option-btn.selected {
            background-color: var(--primary-dark);
            color: white;
            border-color: var(--primary-dark);
        }
        
        .option-btn.done-btn {
            background-color: var(--secondary-darkest);
            color: white;
            font-weight: 600;
        }
        /* --- END: CSS FOR OPTIONS --- */


        /* --- 3. AI Input Section --- */
        .ai-input-container {
            width: 100%;
            border-radius: 28px; 
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.08);
            border: 1px solid var(--border-light); 
            overflow: hidden;
            background: #ffffff; 
            flex-shrink: 0;
            margin-top: 1rem;
        }

        .ai-input-box {
            background-color: transparent; 
            padding: 0.5rem 0.75rem; 
            display: flex;
            flex-direction: row; 
            gap: 0.5rem; 
            align-items: center; 
        }

        input#goal-input {
            border: none;
            outline: none;
            background: transparent;
            font-size: 1rem;
            font-family: 'Inter', sans-serif;
            color: #333; 
            width: 100%;
            line-height: 1.6;
            padding: 0.5rem; 
            flex-grow: 1; 
            transition: opacity 0.2s ease;
        }

        input#goal-input:disabled {
            background-color: #f9f9f9;
            opacity: 0.7;
            cursor: not-allowed;
        }


        input#goal-input::placeholder {
            color: #aaa; 
            font-weight: 500;
        }

        .icon-btn {
            background: none;
            border: none;
            cursor: pointer;
            padding: 8px; 
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background-color 0.2s;
        }

        .icon-btn:hover {
            background-color: #f0f0f0; 
        }
        
        .icon-btn svg {
            stroke: #666; 
        }
        
        /* CSS FOR LISTENING STATE */
        .icon-btn#mic-btn.listening svg {
            stroke: #D93025;
            animation: pulse-mic 1.5s infinite ease-in-out;
        }
        
        @keyframes pulse-mic {
            0% { transform: scale(1); }
            50% { transform: scale(1.2); }
            100% { transform: scale(1); }
        }
        
        
        .send-btn {
            background-color: var(--secondary-darkest); 
            color: white;
            border: none;
            width: 38px; 
            height: 38px; 
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s;
            flex-shrink: 0; 
        }
        
        .send-btn:hover {
            background-color: var(--primary-dark); 
        }
        
        .send-btn:disabled {
            background-color: #aaa;
            cursor: not-allowed;
        }
        
        .send-btn svg {
            stroke: white;
        }


        /* --- Custom Alert Modal --- */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.4);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            padding: 1rem;
        }
        .modal-box {
            background: white;
            padding: 1.5rem 2rem;
            border-radius: 12px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.15);
            max-width: 400px;
            width: 100%;
            text-align: center;
        }
        .modal-box p {
            font-size: 1rem;
            color: #333;
            margin-bottom: 1.5rem;
            line-height: 1.5;
        }
        .modal-close-btn {
            background-color: var(--primary-dark); 
            color: white;
            border: none;
            border-radius: 8px;
            padding: 10px 18px;
            font-size: 0.95rem;
            font-weight: 600;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .modal-close-btn:hover {
            background-color: var(--primary-medium); 
        }

        /* --- ADDED: RESUME PREVIEW STYLES (ATS-Friendly, Simple) --- */
        #resume-preview-container {
            display: none; /* Hide by default */
            flex-direction: column;
            width: 100%;
            flex-grow: 1;
            background: #ffffff;
            border-radius: 12px;
            padding: 2rem;
            box-shadow: 0 4px 12px rgba(0,0,0,0.05);
            font-family: 'Inter', sans-serif;
            overflow-y: auto;
        }
        #resume-preview-container.visible {
            display: flex;
        }

        /* Styles for PDF print/preview layout (A4-ish size) */
        .resume-content {
            max-width: 750px; /* A4 width proxy */
            margin: 0 auto;
            color: #111;
        }
        .resume-header-info {
            text-align: center;
            padding-bottom: 10px;
            border-bottom: 2px solid var(--secondary-darkest);
            margin-bottom: 15px;
        }
        .resume-header-info h2 {
            font-size: 2rem;
            font-weight: 700;
            margin-bottom: 5px;
        }
        .resume-header-info p {
            font-size: 0.9rem;
            margin: 2px 0;
        }
        .resume-section {
            margin-bottom: 15px;
            padding-top: 5px;
        }
        .resume-section h3 {
            font-size: 1.1rem;
            font-weight: 700;
            color: var(--primary-dark);
            border-bottom: 1px solid #ddd;
            padding-bottom: 5px;
            margin-bottom: 8px;
        }
        .resume-item {
            margin-bottom: 10px;
        }
        .resume-item p, .resume-item ul {
            font-size: 0.95rem;
            line-height: 1.4;
            margin-left: 15px;
        }
        .resume-item strong {
            display: block;
            font-weight: 600;
            margin-left: 0;
            font-size: 1rem;
        }
        .resume-item ul {
            list-style-type: disc;
            margin-top: 5px;
            padding-left: 20px;
        }
        /* Print-specific styles to ensure clean PDF output */
        @media print {
            body, .resume-content {
                background: white !important;
                color: black !important;
            }
            .resume-header-info {
                border-bottom: 2px solid black !important;
            }
            .resume-section h3 {
                border-bottom: 1px solid black !important;
                color: black !important;
            }
            .top-bar, .ai-input-container, .options-container, .modal-overlay, #chat-display, #download-area {
                display: none !important;
            }
            #resume-preview-container {
                display: block !important;
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: auto;
                padding: 0;
                box-shadow: none;
                overflow: visible;
            }
            .container {
                padding: 0;
                height: auto;
            }
        }
    </style>
</head>
<body>

    <nav class="top-bar">
        <div class="logo" data-translation-key="app_name">Resume Maker</div>
        
        <div style="display: flex; align-items: center;">
            <button class="mode-btn" id="online-mode-btn">
                <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path>
                    <path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path>
                </svg>
                <span data-translation-key="online_mode_label">Online Builder</span>
            </button>
            
            <div class="language-switcher">
                <button class="language-btn" id="language-toggle-btn" aria-haspopup="true" aria-expanded="false">
                    <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="#333" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <circle cx="12" cy="12" r="10"></circle>
                        <line x1="2" y1="12" x2="22" y2="12"></line>
                        <path d="M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z"></path>
                    </svg>
                    <span id="current-lang-text">English</span>
                </button>
                
                <div class="language-dropdown" id="language-dropdown-menu" role="menu">
                    <a href="#" class="language-option selected" role="menuitem" data-lang="en">English</a>
                    <a href="#" class="language-option" role="menuitem" data-lang="hi">हिन्दी (Hindi)</a>
                    <a href="#" class="language-option" role="menuitem" data-lang="bn">বাংলা (Bengali)</a>
                    <a href="#" class="language-option" role="menuitem" data-lang="te">తెలుగు (Telugu)</a>
                    <a href="#" class="language-option" role="menuitem" data-lang="mr">मराठी (Marathi)</a>
                    <a href="#" class="language-option" role="menuitem" data-lang="ta">தமிழ் (Tamil)</a>
                    <a href="#" class="language-option" role="menuitem" data-lang="ur">اردো (Urdu)</a>
                    <a href="#" class="language-option" role="menuitem" data-lang="gu">ગુજરાતી (Gujarati)</a>
                    <a href="#" class="language-option" role="menuitem" data-lang="kn">ಕನ್ನಡ (Kannada)</a>
                    <a href="#" class="language-option" role="menuitem" data-lang="ml">മലയാളം (Malayalam)</a>
                    <a href="#" class="language-option" role="menuitem" data-lang="pa">ਪੰਜਾਬੀ (Punjabi)</a>
                    <a href="#" class="language-option" role="menuitem" data-lang="or">ଓଡ଼ିଆ (Odia)</a>
                    <a href="#" class="language-option" role="menuitem" data-lang="as">অসমীয়া (Assamese)</a>
                    <a href="#" class="language-option" role="menuitem" data-lang="mai">मैथिली (Maithili)</a>
                    <a href="#" class="language-option" role="menuitem" data-lang="sat">संताली (Santali)</a>
                    <a href="#" class="language-option" role="menuitem" data-lang="ks">कश्मीरी (Kashmiri)</a>
                    <a href="#" class="language-option" role="menuitem" data-lang="ne">नेपाली (Nepali)</a>
                    <a href="#" class="language-option" role="menuitem" data-lang="sd">सिन्धी (Sindhi)</a>
                    <a href="#" class="language-option" role="menuitem" data-lang="kok">कोंकणी (Konkani)</a>
                    <a href="#" class="language-option" role="menuitem" data-lang="doi">डोगरी (Dogri)</a>
                    <a href="#" class="language-option" role="menuitem" data-lang="mni">মৈতৈলোন্ (Manipuri)</a>
                </div>
            </div>
        </div>
    </nav>
    <main class="container">
        <header class="header-content" id="header-content">
            <span class="ai-tag" data-translation-key="offline_tag">Local Mode Active</span>
            <h1 data-translation-key="welcome_title">Welcome to Technolize</h1>
            <p class="subtitle" data-translation-key="subtitle_offline">
                You are currently in **Offline Builder Mode**. Generate your professional resume locally with stored assets and core functionality.
            </p>

            <button class="create-goal-btn" id="create-goal-btn" disabled>
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                    <line x1="12" y1="5" x2="12" y2="19"></line>
                    <line x1="5" y1="12" x2="19" y2="12"></line>
                </svg>
                <span id="create-goal-btn-text" data-translation-key="lets_make">Loading...</span>
            </button>

        </header>

        <section class="chat-display-area" id="chat-display"></section>
        
        <section id="resume-preview-container">
            <div id="resume-content" class="resume-content">
                </div>
            <div class="options-container" id="download-area" style="padding-left: 0; margin-top: 1.5rem;">
                 <button class="option-btn done-btn" id="download-pdf-btn" style="padding: 12px 20px; font-size: 1rem;">
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="margin-right: 5px;">
                        <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path>
                        <polyline points="14 2 14 8 20 8"></polyline>
                        <line x1="12" y1="13" x2="12" y2="19"></line>
                        <polyline points="15 16 12 19 9 16"></polyline>
                    </svg>
                    <span data-translation-key="download_pdf">Download Resume as PDF</span>
                 </button>
            </div>
        </section>

        <section class="ai-input-container">
            <div class="ai-input-box">
                <button class="icon-btn" id="tts-btn" 
                    aria-label="Read text aloud"
                    data-translation-key="alert_tts" 
                    data-translation-attr="aria-label">
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke-width="2" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round">
                        <polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon>
                        <path d="M19.07 4.93a10 10 0 0 1 0 14.14M15.54 8.46a5 5 0 0 1 0 7.07"></path>
                    </svg>
                </button>

                <input type="text" id="goal-input" 
                    placeholder="Please wait..." 
                    data-translation-key="type_answer"
                    data-translation-attr="placeholder"
                    disabled>

                <button class="icon-btn" id="mic-btn" 
                    aria-label="Use microphone"
                    data-translation-key="alert_voice"
                    data-translation-attr="aria-label">
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"></path>
                        <path d="M19 10v2a7 7 0 0 1-14 0v-2"></path>
                        <line x1="12" y1="19" x2="12" y2="22"></line>
                    </svg>
                </button>
                
                <button class="send-btn" 
                    aria-label="Generate"
                    data-translation-key="next"
                    data-translation-attr="aria-label"
                    disabled>
                    <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
                        <line x1="12" y1="19" x2="12" y2="5"></line>
                        <polyline points="5 12 12 5 19 12"></polyline>
                    </svg>
                </button>
            </div>
        </section>

    </main>

    <div class="modal-overlay" id="custom-alert-overlay">
        <div class="modal-box">
            <p id="custom-alert-message">This is an alert message.</p>
            <button class="modal-close-btn" id="custom-alert-close" data-translation-key="next">OK</button>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {

            // --- State Variables ---
            let currentLang = 'en';
            let translations = {}; 
            let chatState = 'awaiting_profession'; 
            let currentQuestionSet = [];
            let currentQuestionIndex = 0;
            let resumeData = {}; 
            
            // --- TTS State ---
            const synth = window.speechSynthesis;
            let lastSpokenText = "";
            let isSpeaking = false;

            const langMap = {
                'en': 'en-US', 'hi': 'hi-IN', 'bn': 'bn-IN', 'te': 'te-IN', 'mr': 'mr-IN',
                'ta': 'ta-IN', 'ur': 'ur-IN', 'gu': 'gu-IN', 'kn': 'kn-IN', 'ml': 'ml-IN',
                'pa': 'pa-IN', 'or': 'or-IN', 'as': 'as-IN', 'mai': 'hi-IN', 
                'sat': 'hi-IN', 'ks': 'ur-IN', 'ne': 'ne-NP', 'sd': 'ur-IN',
                'kok': 'mr-IN', 'doi': 'hi-IN', 'mni': 'bn-IN'
            };
            
            // --- Speech Recognition State ---
            let recognition;
            let isRecognizing = false;
            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            const micBtn = document.querySelector('#mic-btn'); 
            
            if (!SpeechRecognition) {
                console.warn("Speech Recognition API not supported in this browser.");
                if(micBtn) micBtn.style.display = 'none'; 
            }
            
            const professions = [
                { key: 'cook' }, { key: 'electrical' }, { key: 'plumbing' },
                { key: 'driver' }, { key: 'carpentry' }, { key: 'welding' },
                { key: 'masonry' }, { key: 'painting' }, { key: 'mechanic' },
                { key: 'factory' }, { key: 'farm' }, { key: 'security' },
                { key: 'cleaning' }, { key: 'tailor' }, { key: 'construction' },
                { key: 'automotive' }, { key: 'general' } 
            ];

            // --- DOM Elements ---
            const alertOverlay = document.getElementById('custom-alert-overlay');
            const alertMessage = document.getElementById('custom-alert-message');
            const alertCloseBtn = document.getElementById('custom-alert-close');
            const chatDisplay = document.getElementById('chat-display');
            const headerContent = document.getElementById('header-content');
            const createGoalBtn = document.getElementById('create-goal-btn');
            const sendBtn = document.querySelector('.send-btn');
            const ttsBtn = document.querySelector('#tts-btn');
            const goalInput = document.getElementById('goal-input');
            const langButton = document.getElementById('language-toggle-btn');
            const langDropdown = document.getElementById('language-dropdown-menu');
            const langButtonText = document.getElementById('current-lang-text');
            const langOptions = document.querySelectorAll('.language-option');
            const onlineModeBtn = document.getElementById('online-mode-btn'); 

            // ADDED: Resume Preview DOM
            const resumePreviewContainer = document.getElementById('resume-preview-container');
            const resumeContent = document.getElementById('resume-content');
            const downloadArea = document.getElementById('download-area');
            const downloadPdfBtn = document.getElementById('download-pdf-btn');

            // --- Initialization ---
            (async () => {
                const cachedLang = localStorage.getItem('currentLang') || 'en'; // Try to load last used language
                currentLang = cachedLang;
                await loadTranslations(currentLang);
                if (SpeechRecognition) {
                    setupSpeechRecognition(); 
                }
                
                // --- CRITICAL OFFLINE LOAD: Load questions and display welcome message
                const welcomeMsg = translations['welcome_message_offline'] || "Welcome to Offline Builder. All core functionality is available. Internet is only required to upload the final resume.";
                
                // Show initial alert for offline mode
                showCustomAlert(welcomeMsg); 

            })();
            
            // --- Core TTS Functions (Updated to track speaking state) ---
            function stopSpeech() {
                if (synth && synth.speaking) {
                    synth.cancel();
                }
                isSpeaking = false;
            }

            function speakText(text, langCode) {
                if (!synth) {
                    console.warn("Speech Synthesis not supported.");
                    return;
                }
                
                stopSpeech(); // Stop any previous speech
                
                const utterance = new SpeechSynthesisUtterance(text);
                utterance.lang = langMap[langCode] || langCode;
                utterance.rate = 0.95;
                utterance.pitch = 1;
                
                lastSpokenText = text;
                isSpeaking = true;
                
                utterance.onend = () => { isSpeaking = false; };
                utterance.onerror = (event) => {
                    console.error("TTS Error:", event.error);
                    isSpeaking = false;
                };

                let voices = synth.getVoices().filter(voice => voice.lang === utterance.lang);

                if (voices.length > 0) {
                    utterance.voice = voices[0];
                    synth.speak(utterance);
                } else {
                    synth.speak(utterance);
                }
            }
            // --- End TTS Functions ---

            // --- Core Functions ---

            function applyTranslations() {
                // (Translation logic remains the same)
                if (!translations) {
                    console.error("No translations loaded.");
                    return;
                }
                // 1. Translate static elements
                document.querySelectorAll('[data-translation-key]').forEach(element => {
                    const key = element.dataset.translationKey;
                    let translation = translations[key];

                    // Special case for offline subtitle
                    if (key === 'subtitle_offline') {
                         translation = translations['subtitle_offline'] || "You are currently in **Offline Builder Mode**. Generate your professional resume locally with stored assets and core functionality.";
                    } else if (key === 'offline_tag') {
                         translation = translations['offline_tag'] || "Local Mode Active";
                    } else if (!translation) {
                        translation = translations[element.dataset.translationKey.replace('_offline', '')];
                    }

                    if (translation) {
                        const attr = element.dataset.translationAttr;
                        if (attr) {
                            element.setAttribute(attr, translation);
                        } else {
                            element.textContent = translation;
                        }
                    }
                });
                
                updatePlaceholder();
                
                if (createGoalBtn && createGoalBtn.disabled) {
                    createGoalBtn.disabled = false;
                    const btnText = document.getElementById('create-goal-btn-text');
                    if (btnText) {
                        btnText.textContent = translations['lets_make'] || "Let's Make";
                        btnText.dataset.translationKey = 'lets_make'; 
                    }
                }
                
                // 2. Translate options (buttons)
                document.querySelectorAll('.option-btn').forEach(btn => {
                    let key = btn.dataset.key;
                    let text = "Error";
                    if (btn.classList.contains('profession-btn')) {
                        key = btn.dataset.key;
                        text = (translations.professions && translations.professions[key]) ? translations.professions[key] : key;
                    } else if (btn.classList.contains('done-btn')) {
                        text = translations['next'] || 'Done';
                    } else {
                        const qId = btn.dataset.questionId;
                        const index = btn.dataset.index;
                        if (qId && index !== undefined && translations.options && translations.options[qId] && translations.options[qId][index]) {
                            text = translations.options[qId][index];
                        } else {
                            text = key;
                        }
                    }
                    btn.textContent = text;
                    btn.dataset.text = text;
                });
                
                // 3. FIX: Re-translate all existing dynamic chat messages
                document.querySelectorAll('.chat-message .bot-message-text, .chat-message .user-message-text').forEach(element => {
                    const key = element.dataset.translationKey;
                    if (!key) return;
                    try {
                        if (key.startsWith('{')) {
                            const data = JSON.parse(key);
                            const newTexts = data.indices.map(index => {
                                const numIndex = parseInt(index, 10);
                                return translations.options[data.qId][numIndex] || `opt_${numIndex}`;
                            });
                            element.textContent = newTexts.join(', ');
                        } else if (key === 'none') {
                            element.textContent = translations['none'] || 'None';
                        } else if (key === 'profession_selected') {
                            // Find the original key to get the translated profession name
                            const originalKey = resumeData.profession; 
                            const translatedProfession = translations.professions[originalKey] || element.dataset.professionText;
                            element.textContent = (translations['profession_selected'] || 'Great! {profession}.')
                                .replace('{profession}', translatedProfession);
                            // IMPORTANT: Keep the translated text cached on the element itself for user messages
                            element.dataset.professionText = translatedProfession; 
                        } else if (translations[key]) {
                            element.textContent = translations[key];
                        } else {
                            const parts = key.split('.');
                            if (parts.length === 2 && parts[0] === 'questions' && translations.questions && translations.questions[parts[1]]) {
                                element.textContent = translations.questions[parts[1]];
                            } else if (parts.length === 2 && parts[0] === 'professions' && translations.professions && translations.professions[parts[1]]) {
                                element.textContent = translations.professions[parts[1]];
                            } else if (parts.length === 3 && parts[0] === 'options' && translations.options && translations.options[parts[1]] && translations.options[parts[1]][parts[2]]) {
                                const numIndex = parseInt(parts[2], 10);
                                element.textContent = translations.options[parts[1]][numIndex];
                            }
                        }
                    } catch (e) {
                        console.error(`Error re-translating key: ${key}`, e);
                    }
                });
            }
            
            async function loadTranslations(langCode) {
                // Modified to first check localStorage for cached translations
                const cachedTranslations = localStorage.getItem('cached_translations');
                if (cachedTranslations) {
                    const parsedCache = JSON.parse(cachedTranslations);
                    if (parsedCache[langCode]) {
                         translations = parsedCache[langCode];
                         console.log(`Translations loaded from CACHE for: ${langCode}`);
                         applyTranslations();
                         return;
                    }
                }
                
                // Fallback to fetch (assumes local files are cached via Service Worker or locally available)
                try {
                    const response = await fetch(`assets/translations/${langCode}.json`);
                    if (!response.ok) {
                        throw new Error(`Local file not found for ${langCode}.json`);
                    }
                    translations = await response.json();
                    console.log(`Translations loaded from LOCAL FILES for: ${langCode}`);

                    // Update cache for other languages if not present (simplified cache update logic)
                    if (cachedTranslations) {
                        const parsedCache = JSON.parse(cachedTranslations);
                        parsedCache[langCode] = translations;
                        localStorage.setItem('cached_translations', JSON.stringify(parsedCache));
                    } else {
                        localStorage.setItem('cached_translations', JSON.stringify({ [langCode]: translations }));
                    }

                } catch (error) {
                    console.error(`Error loading translations for ${langCode}. Falling back to default 'en':`, error);
                    // Use a minimal hardcoded English fallback if all else fails
                    if (langCode !== 'en') {
                         await loadTranslations('en'); 
                         return;
                    } else {
                         translations = {
                             'welcome_title': 'Offline Builder',
                             'subtitle_offline': 'Local Mode Active. Build resume with limited functionality.',
                             'lets_make': 'Start Building',
                             'type_answer': 'Type your answer...',
                             'select_profession': 'Select or Type...',
                             'next': 'OK',
                             'welcome_message': "Hello! I'm your resume assistant.",
                             'select_profession_prompt': "To start, please choose your profession from the list below.",
                             'alert_lang_change': 'Language set to',
                             // ADDED TRANSLATION KEYS FOR DOWNLOAD
                             'download_pdf': 'Download Resume as PDF', 
                             'resume_complete_offline': 'All questions answered! Your resume data is now ready and stored locally.',
                             'preview_and_download': 'Preview & Download Resume',
                             'raw_data_title': 'Raw Resume Data',
                             'upload_online': 'Upload Online (Requires Internet)',
                         };
                    }
                }
                applyTranslations();
            }
            
            function updatePlaceholder() {
                // (Same as original)
                if (!translations) return; 
                if (goalInput.disabled) {
                    goalInput.placeholder = translations['select_profession'] || 'Please select an option...';
                } else {
                    goalInput.placeholder = translations['type_answer'] || 'Type...';
                }
            }

            function addChatMessage(message, sender, options = {}) {
                // (Same as original)
                if (!chatDisplay || message === undefined) {
                    console.error("Attempted to add undefined message or chatDisplay not found.");
                    return; 
                }; 
                const typingIndicator = chatDisplay.querySelector('.typing-indicator');
                if (typingIndicator) {
                    typingIndicator.remove();
                }
                const messageElement = document.createElement('div');
                messageElement.classList.add('chat-message');
                let textSpan;
                if (sender === 'bot') {
                    messageElement.classList.add('bot-message');
                    messageElement.innerHTML = `
                        <div class="bot-icon">
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="white"><path d="M12 4c-4.418 0-8 3.582-8 8s3.582 8 8 8 8-3.582 8-8-3.582-8-8-8zM12 18c-3.314 0-6-2.686-6-6s2.686-6 6-6 6 2.686 6 6-2.686 6-6 6zM9 12c-0.552 0-1-0.448-1-1s0.448-1 1-1 1 0.448 1 1-0.448 1-1 1zM15 12c-0.552 0-1-0.448-1-1s0.448-1 1-1 1 0.448 1 1-0.448 1-1 1zM8 15h8v-1H8v1z"/></svg>
                        </div>
                        <span class="bot-message-text">${message}</span>
                    `;
                    textSpan = messageElement.querySelector('.bot-message-text');
                } else if (sender === 'typing') {
                    messageElement.classList.add('bot-message', 'typing-indicator');
                    messageElement.innerHTML = `
                        <div class="bot-icon">
                            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="white"><path d="M12 4c-4.418 0-8 3.582-8 8s3.582 8 8 8 8-3.582 8-8-3.582-8-8-8zM12 18c-3.314 0-6-2.686-6-6s2.686-6 6-6 6 2.686 6 6-2.686 6-6 6zM9 12c-0.552 0-1-0.448-1-1s0.448-1 1-1 1 0.448 1 1-0.448 1-1 1zM15 12c-0.552 0-1-0.448-1-1s0.448-1 1-1 1 0.448 1 1-0.448 1-1 1zM8 15h8v-1H8v1z"/></svg>
                        </div>
                        <span class="bot-message-text">
                            <div class="dot"></div><div class="dot"></div><div class="dot"></div>
                        </span>
                    `;
                } else {
                    messageElement.classList.add('user-message');
                    messageElement.innerHTML = `
                        <span class="user-message-text">${message}</span>
                        <div class="user-icon">
                             <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M20 21v-2a4 4 4 0 0 0-4-4H8a4 4 4 0 0 0-4 4v2"></path><circle cx="12" cy="7" r="4"></circle></svg>
                        </div>
                    `;
                    textSpan = messageElement.querySelector('.user-message-text');
                }
                if (textSpan) {
                    if (options.translationKey) {
                        textSpan.dataset.translationKey = options.translationKey;
                    }
                    if (options.professionText) {
                        textSpan.dataset.professionText = options.professionText;
                    }
                }
                chatDisplay.appendChild(messageElement);
                chatDisplay.scrollTop = chatDisplay.scrollHeight;
            }
            
            function showTypingAndReply(callback) {
                // (Same as original)
                addChatMessage(null, 'typing');
                setTimeout(() => {
                    callback();
                }, 1200);
            }

            function displayProfessionOptions() {
                // (Same as original)
                removeOptions(); 
                const optionsContainer = document.createElement('div');
                optionsContainer.className = 'options-container';
                professions.forEach(prof => {
                    const button = document.createElement('button');
                    button.className = 'option-btn profession-btn'; 
                    const text = (translations.professions && translations.professions[prof.key])
                                            ? translations.professions[prof.key]
                                            : prof.key;
                    button.textContent = text;
                    button.dataset.key = prof.key; 
                    button.dataset.text = text;
                    button.addEventListener('click', handleProfessionClick);
                    optionsContainer.appendChild(button);
                });
                chatDisplay.appendChild(optionsContainer);
                chatDisplay.scrollTop = chatDisplay.scrollHeight;
            }

            async function handleProfessionClick(event) {
                // (Same as original)
                stopSpeech();
                const professionKey = event.target.dataset.key; 
                const professionText = event.target.dataset.text; 
                // IMPORTANT: The user message must contain the original key for the next translations to work.
                addChatMessage(professionText, 'user', { translationKey: `professions.${professionKey}` });
                removeOptions();
                showTypingAndReply(async () => {
                    await handleProfessionInput(professionKey, professionText);
                });
            }

            function displayOptions(questionId, optionKeys, type) {
                // (Same as original)
                removeOptions(); 
                const optionsContainer = document.createElement('div');
                optionsContainer.className = 'options-container';
                optionsContainer.dataset.questionId = questionId;
                optionKeys.forEach((key, index) => {
                    const button = document.createElement('button');
                    button.className = 'option-btn';
                    const translatedText = (translations.options && translations.options[questionId] && translations.options[questionId][index])
                                                     ? translations.options[questionId][index]
                                                     : key; 
                    button.textContent = translatedText;
                    button.dataset.key = key; 
                    button.dataset.text = translatedText; 
                    button.dataset.type = type;
                    button.dataset.questionId = questionId;
                    button.dataset.index = index;
                    button.addEventListener('click', handleOptionClick);
                    optionsContainer.appendChild(button);
                });
                if (type === 'multi-select') {
                    const doneButton = document.createElement('button');
                    doneButton.className = 'option-btn done-btn';
                    doneButton.textContent = translations['next'] || 'Done';
                    doneButton.dataset.key = 'done';
                    doneButton.dataset.type = type;
                    doneButton.addEventListener('click', handleOptionClick);
                    optionsContainer.appendChild(doneButton);
                }
                chatDisplay.appendChild(optionsContainer);
                chatDisplay.scrollTop = chatDisplay.scrollHeight;
            }
            
            function handleOptionClick(event) {
                // (Same as original)
                stopSpeech();
                const clickedBtn = event.target;
                const type = clickedBtn.dataset.type;
                const key = clickedBtn.dataset.key;
                const text = clickedBtn.dataset.text;
                const questionId = currentQuestionSet[currentQuestionIndex].id;
                const index = clickedBtn.dataset.index;

                if (type === 'mcq') {
                    resumeData[questionId] = key; 
                    addChatMessage(text, 'user', { translationKey: `options.${questionId}.${index}` }); 
                    removeOptions();
                    currentQuestionIndex++;
                    showTypingAndReply(askNextQuestion);
                } else if (type === 'multi-select') {
                    if (key === 'done') {
                        const selectedButtons = document.querySelectorAll('.option-btn.selected');
                        const selectedKeys = [];
                        const selectedTexts = [];
                        const selectedIndices = [];
                        selectedButtons.forEach(btn => {
                            selectedKeys.push(btn.dataset.key);
                            selectedTexts.push(btn.dataset.text);
                            selectedIndices.push(btn.dataset.index);
                        });
                        resumeData[questionId] = selectedKeys;
                        let joinedText;
                        let translationKey;
                        if (selectedTexts.length > 0) {
                            joinedText = selectedTexts.join(', ');
                            translationKey = JSON.stringify({ qId: questionId, indices: selectedIndices });
                        } else {
                            joinedText = translations['none'] || "None";
                            translationKey = 'none';
                        }
                        addChatMessage(joinedText, 'user', { translationKey: translationKey });
                        removeOptions();
                        currentQuestionIndex++;
                        showTypingAndReply(askNextQuestion);
                    } else {
                        clickedBtn.classList.toggle('selected');
                    }
                }
            }
            
            function removeOptions() {
                // (Same as original)
                const existingOptions = chatDisplay.querySelector('.options-container');
                if (existingOptions) {
                    existingOptions.remove();
                }
            }

            function handleUserInput() {
                // (Same as original)
                stopSpeech();
                if (goalInput.disabled) return;
                const inputText = goalInput.value.trim();
                if (!inputText) {
                    showCustomAlert(translations['alert_required'] || "Please type a message.");
                    return;
                }
                addChatMessage(inputText, 'user');
                goalInput.value = '';
                showTypingAndReply(async () => {
                    if (chatState === 'asking_questions') {
                        const question = currentQuestionSet[currentQuestionIndex];
                        resumeData[question.id] = inputText;
                        currentQuestionIndex++;
                        askNextQuestion();
                    }
                });
            }

            async function handleProfessionInput(professionKey, professionText) {
                // Modified for offline: only load from local `assets/questions/`
                try {
                    const response = await fetch(`assets/questions/${professionKey}.json`);
                    if (!response.ok) {
                        throw new Error(`File not found for ${professionKey}, using general.`);
                    }
                    const data = await response.json();
                    currentQuestionSet = data.questions; 
                } catch (e) {
                    console.warn(e.message);
                    const response = await fetch(`assets/questions/general.json`);
                    const data = await response.json();
                    currentQuestionSet = data.questions;
                    professionKey = 'general'; 
                }
                chatState = 'asking_questions'; 
                currentQuestionIndex = 0;
                resumeData = { 'profession': professionKey }; 
                
                // The acknowledgement message uses the translated text from the button,
                // but the underlying key must be stored for re-translation later.
                const ackMsg = (translations['profession_selected'] || 'Great! {profession}.')
                                           .replace('{profession}', professionText);
                addChatMessage(ackMsg, 'bot', { 
                    translationKey: 'profession_selected', 
                    professionText: professionKey // Store the KEY here, not the display text
                });
                speakText(ackMsg, currentLang); 
                setTimeout(askNextQuestion, 800);
            }

            function askNextQuestion() {
                // (Same as original)
                stopSpeech();
                removeOptions(); 

                if (currentQuestionIndex < currentQuestionSet.length) {
                    const question = currentQuestionSet[currentQuestionIndex];
                    const questionText = (translations.questions && translations.questions[question.id])
                                                     ? translations.questions[question.id]
                                                     : (question.question || `Missing question for ${question.id}`);
                    
                    addChatMessage(questionText, 'bot', { translationKey: `questions.${question.id}` });
                    
                    let textToSpeak = questionText;

                    if (question.type === 'text' || question.type === 'tel' || question.type === 'email') {
                        goalInput.disabled = false;
                        sendBtn.disabled = false;
                        micBtn.disabled = false;
                        ttsBtn.disabled = false;
                        goalInput.placeholder = translations['type_answer'] || 'Type your answer...';
                        goalInput.focus();
                    } else if (question.type === 'mcq' || question.type === 'multi-select') {
                        goalInput.disabled = true;
                        sendBtn.disabled = true;
                        micBtn.disabled = false; // Still allow voice input to click options
                        ttsBtn.disabled = false;
                        goalInput.placeholder = translations['select_profession'] || 'Please select an option...';
                        
                        displayOptions(question.id, question.options, question.type); 

                        const optionsContainer = chatDisplay.querySelector('.options-container');
                        let optionsText = "";
                        if (optionsContainer) {
                            const optionButtons = optionsContainer.querySelectorAll('.option-btn:not(.done-btn)');
                            optionButtons.forEach((btn, index) => {
                                optionsText += `${index + 1}. ${btn.dataset.text}. `;
                            });
                        }
                        textToSpeak += " " + optionsText; 
                    }

                    speakText(textToSpeak, currentLang);

                } else {
                    chatState = 'completed'; 
                    processCompletedResumeData(); // NEW: Call the final processing function
                }
            }
            
            /* --- UPDATED: Resume Generation Functions --- */
            
            function generateResumePreview() {
                // Hide chat and show resume preview
                chatDisplay.classList.remove('visible');
                downloadArea.style.display = 'flex';
                resumePreviewContainer.classList.add('visible');
                
                const data = resumeData;
                const resumeHtml = `
                    <div class="resume-header-info">
                        <h2>${data.fullName || (translations.questions && translations.questions.fullName) || 'Your Name'}</h2>
                        <p>${data.mobileNumber || (translations.questions && translations.questions.mobileNumber) || ''} | 
                           ${data.emailAddress || (translations.questions && translations.questions.emailAddress) || ''} | 
                           ${data.currentCity || (translations.questions && translations.questions.currentCity) || ''}</p>
                    </div>

                    <div class="resume-section" id="objective-section">
                        <h3>${translations.section_objective || 'OBJECTIVE'}</h3>
                        <div class="resume-item">
                            <p>${data.objective || (translations.default_objective || 'Seeking a challenging position to utilize skills and contribute to company success.')}</p>
                        </div>
                    </div>

                    <div class="resume-section" id="experience-section">
                        <h3>${translations.section_experience || 'WORK EXPERIENCE'}</h3>
                        <div class="resume-item">
                            <strong>${data.jobTitle || translations.professions[data.profession] || 'Job Title'}</strong>
                            <p>${data.companyName || 'Company Name'} | ${data.jobCity || 'City'} | ${data.yearsOfExperience || 'X'} Years</p>
                            <ul>
                                <li>${data.keyAchievement1 || (translations.default_achievement_1 || 'Successfully managed daily operations and met production targets.')}</li>
                                <li>${data.keyAchievement2 || (translations.default_achievement_2 || 'Maintained a clean and safe working environment.')}</li>
                            </ul>
                        </div>
                    </div>
                    
                    <div class="resume-section" id="skills-section">
                        <h3>${translations.section_skills || 'SKILLS'}</h3>
                        <div class="resume-item">
                            <p><strong>${translations.skill_languages || 'Languages'}:</strong> ${(data.languages && data.languages.length > 0) ? data.languages.map(k => translations.options.languages[k] || k).join(', ') : 'Not Specified'}</p>
                            <p><strong>${translations.skill_tools || 'Tools'}:</strong> ${(data.tools && data.tools.length > 0) ? data.tools.map(k => translations.options.tools[k] || k).join(', ') : 'Not Specified'}</p>
                            <p><strong>${translations.skill_other || 'Other Skills'}:</strong> ${data.otherSkills || 'Hard-working, Punctual, Team Player'}</p>
                        </div>
                    </div>
                    
                    <div class="resume-section" id="education-section">
                        <h3>${translations.section_education || 'EDUCATION'}</h3>
                        <div class="resume-item">
                            <p><strong>${data.qualification || 'Qualification'}</strong>, ${data.schoolCollege || 'School/College Name'}</p>
                            <p>${data.passingYear || 'Year'} | ${data.educationCity || 'City'}</p>
                        </div>
                    </div>
                `;
                
                resumeContent.innerHTML = resumeHtml;
            }

            function downloadResumePdf() {
                const element = document.getElementById('resume-content');
                const fullName = resumeData.fullName ? resumeData.fullName.replace(/\s+/g, '_') : 'Resume';
                const filename = `${fullName}_Offline.pdf`;
                
                // Hide download area before converting
                downloadArea.style.display = 'none';

                // Use html2canvas and jsPDF for modern HTML rendering
                html2canvas(element, { 
                    scale: 2, // Improves quality
                    useCORS: true,
                    allowTaint: true 
                }).then(canvas => {
                    const imgData = canvas.toDataURL('image/jpeg', 1.0);
                    const pdf = new jsPDF('p', 'mm', 'a4'); // Portrait, mm, A4

                    const imgWidth = 210; // A4 width in mm
                    const pageHeight = 297; // A4 height in mm
                    const imgHeight = canvas.height * imgWidth / canvas.width;
                    let heightLeft = imgHeight;
                    let position = 0;

                    pdf.addImage(imgData, 'JPEG', 0, position, imgWidth, imgHeight);
                    heightLeft -= pageHeight;

                    // Multi-page logic for long resumes
                    while (heightLeft >= 0) {
                        position = heightLeft - imgHeight;
                        pdf.addPage();
                        pdf.addImage(imgData, 'JPEG', 0, position, imgWidth, imgHeight);
                        heightLeft -= pageHeight;
                    }

                    pdf.save(filename);
                    
                    // Show download area again
                    downloadArea.style.display = 'flex';
                }).catch(error => {
                    console.error("PDF generation error:", error);
                    showCustomAlert(translations.alert_pdf_error || "Failed to generate PDF. Please try again or use the print option.");
                    downloadArea.style.display = 'flex';
                });
            }

            // --- END: Resume Generation Functions ---

            
            async function processCompletedResumeData() {
                // Store resume data locally for persistence
                localStorage.setItem('localResumeData', JSON.stringify(resumeData));

                goalInput.disabled = true;
                sendBtn.disabled = true;
                micBtn.disabled = true;
                ttsBtn.disabled = true;
                goalInput.placeholder = translations['type_answer'] || 'Resume Ready!';
                
                // Show final message
                const processingMsg = translations['resume_complete_offline'] || 'All questions answered! Your resume data is now ready and stored locally. You can preview and download your professional resume now.';
                addChatMessage(processingMsg, 'bot', { translationKey: 'resume_complete_offline' });
                speakText(processingMsg, currentLang);
                
                // Remove existing options (if any)
                removeOptions();
                
                // Display the new button immediately in the chat area (or below it)
                const finalOptionsContainer = document.createElement('div');
                finalOptionsContainer.className = 'options-container';

                const previewBtn = document.createElement('button');
                previewBtn.className = 'option-btn done-btn';
                previewBtn.textContent = translations['preview_and_download'] || 'Preview & Download Resume';
                previewBtn.style.backgroundColor = 'var(--primary-dark)';
                previewBtn.addEventListener('click', generateResumePreview); 

                finalOptionsContainer.appendChild(previewBtn);
                
                // Append the button set to the chat area for user interaction
                chatDisplay.appendChild(finalOptionsContainer);
                chatDisplay.scrollTop = chatDisplay.scrollHeight;

                console.log('--- FINAL RESUME DATA (OFFLINE) ---', resumeData);
            }
            
            function showCustomAlert(message) {
                // (Same as original)
                if (alertMessage) alertMessage.textContent = message;
                if (alertOverlay) alertOverlay.style.display = 'flex';
                if (alertCloseBtn) alertCloseBtn.textContent = translations['next'] || 'OK';
            }
            if (alertCloseBtn) {
                alertCloseBtn.addEventListener('click', () => {
                // This ensures the custom alert message is the correct translated "OK" button text
                    if (alertOverlay) alertOverlay.style.display = 'none';
                });
            }
            if (alertOverlay) {
                alertOverlay.addEventListener('click', (event) => {
                    if (event.target === alertOverlay) {
                        alertOverlay.style.display = 'none';
                    }
                });
            }

            function setupSpeechRecognition() {
                // (Same as original)
                if (!SpeechRecognition) return; 
                
                recognition = new SpeechRecognition();
                recognition.lang = langMap[currentLang] || 'en-US';
                recognition.continuous = false;
                recognition.interimResults = false;

                recognition.onstart = () => {
                    isRecognizing = true;
                    micBtn.classList.add('listening');
                    ttsBtn.disabled = true; // Disable TTS while listening
                    const alertMsg = (chatState === 'awaiting_profession')
                        ? (translations['alert_voice_profession'] || "Please say the name of your profession...")
                        : (translations['alert_voice'] || "Listening... Please speak now.");
                    showCustomAlert(alertMsg);
                };

                recognition.onend = () => {
                    isRecognizing = false;
                    micBtn.classList.remove('listening');
                    ttsBtn.disabled = false; // Re-enable TTS after listening
                };

                recognition.onerror = (event) => {
                    console.error("Speech Recognition Error:", event.error);
                    let errorMsg = translations['alert_voice_error'] || "Voice error. Please try again.";
                    
                    if (event.error === 'no-speech') {
                        errorMsg = translations['alert_voice_no_speech'] || "No speech was detected. Please try again.";
                    } else if (event.error === 'not-allowed') {
                        errorMsg = translations['alert_voice_not_allowed'] || "Permission to use microphone was denied. Please allow it in your browser settings.";
                    } else if (event.error === 'network') {
                         errorMsg = translations['alert_voice_network_offline'] || "Voice input may be limited in Offline Mode. Try typing your answer.";
                    }
                    showCustomAlert(errorMsg);
                    ttsBtn.disabled = false;
                };

                recognition.onresult = (event) => {
                    const transcript = event.results[event.results.length - 1][0].transcript.trim(); 

                    if (chatState === 'awaiting_profession') {
                        // (Profession matching logic)
                        const lowerTranscript = transcript.toLowerCase();
                        const professionButtons = document.querySelectorAll('.option-btn.profession-btn');
                        let matchFound = false;

                        for (const btn of professionButtons) {
                            const buttonText = btn.dataset.text.trim().toLowerCase(); 
                            
                            if (buttonText.includes(lowerTranscript) || lowerTranscript.includes(buttonText)) {
                                btn.click();
                                matchFound = true;
                                break; 
                            }
                        }

                        if (!matchFound) {
                            const errorMsgTemplate = translations['alert_voice_profession_nomatch'] || `Could not match "{transcript}". Please clearly say one of the profession names shown.`;
                            const errorMsg = errorMsgTemplate.replace('{transcript}', transcript); 
                            showCustomAlert(errorMsg);
                        }
                    } else if (chatState === 'asking_questions') {
                        const question = currentQuestionSet[currentQuestionIndex];
                        if (question.type === 'mcq' || question.type === 'multi-select') {
                            // NEW: Basic option matching logic for select questions
                            const lowerTranscript = transcript.toLowerCase();
                            const optionsContainer = chatDisplay.querySelector('.options-container');
                            let matchFound = false;

                            if (optionsContainer) {
                                const optionButtons = optionsContainer.querySelectorAll('.option-btn:not(.done-btn)');
                                optionButtons.forEach(btn => {
                                    const buttonText = btn.dataset.text.trim().toLowerCase();
                                    const index = parseInt(btn.dataset.index, 10) + 1; // 1-based index
                                    
                                    // Match by text or by spoken number (e.g., "one" for option 1)
                                    if (buttonText.includes(lowerTranscript) || lowerTranscript.includes(buttonText) || lowerTranscript.includes(String(index))) {
                                        btn.click(); // Click the matched option
                                        matchFound = true;
                                    }
                                });

                                if (question.type === 'multi-select' && (lowerTranscript.includes((translations['next'] || 'done').toLowerCase()))) {
                                    optionsContainer.querySelector('.done-btn').click();
                                    matchFound = true;
                                }
                            }

                            if (!matchFound) {
                                // If nothing matches a button, try treating it as open text if available
                                if (!goalInput.disabled) {
                                    goalInput.value = transcript;
                                    handleUserInput();
                                } else {
                                    showCustomAlert(translations['alert_voice_nomatch'] || `Could not match: "${transcript}". Please click a button.`);
                                }
                            }
                        } else if (!goalInput.disabled) {
                               // Handle text-based input question
                               goalInput.value = transcript;
                               handleUserInput(); 
                        }
                    }
                };
            }
            
            function toggleVoiceRecognition() {
                // (Same as original)
                if (!recognition) {
                    setupSpeechRecognition(); 
                    if (!recognition) { 
                        showCustomAlert(translations['alert_voice_unsupported'] || "Speech recognition is not supported or failed to initialize.");
                        return;
                    }
                }

                if (isRecognizing) {
                    recognition.stop();
                } else {
                    stopSpeech();
                    const newLangCode = langMap[currentLang] || 'en-US'; // Use langMap for a more precise speech code
                    if (recognition.lang !== newLangCode) {
                        recognition.lang = newLangCode;
                        console.log("Updated recognition language to:", newLangCode);
                    }
                    try {
                        recognition.start();
                    } catch (e) {
                        console.error("Error starting speech recognition:", e);
                        showCustomAlert(translations['alert_voice_start_error'] || "Could not start voice input. Please try again.");
                        isRecognizing = false; 
                        micBtn.classList.remove('listening');
                    }
                }
            }

            // --- Hybrid Model Function Stub (Modified to go back to online page) ---
            function switchToOnlineMode() {
                stopSpeech();
                // Note: Resume data is NOT automatically transferred; in a real app, it would be serialized/uploaded.
                showCustomAlert(translations['alert_switch_online'] || "Switching back to Online Builder. Resume data is stored locally. You may need to manually upload it there.");
                setTimeout(() => {
                     // This assumes the online page is named index.html or similar
                    window.location.href = 'index.html'; 
                }, 1500);
            }

            // --- FIX: Welcome Message Sequence ---
            function startChatSequence() {
                 if (headerContent) headerContent.classList.add('hidden');
                 if (resumePreviewContainer) resumePreviewContainer.classList.remove('visible'); // Hide preview
                 if (chatDisplay) chatDisplay.classList.add('visible');
                 goalInput.disabled = true; 
                 sendBtn.disabled = true;
                 micBtn.disabled = false;
                 ttsBtn.disabled = false;
                 updatePlaceholder();

                 // First Message
                 const welcomeMsg = translations['welcome_message'] || "Hello! I'm your AI resume assistant.";
                 addChatMessage(welcomeMsg, 'bot', { translationKey: 'welcome_message' });
                 speakText(welcomeMsg, currentLang);

                 setTimeout(() => {
                    // Second Message (Delayed and runs applyTranslations to ensure the correct language is used)
                    const askProfMsg = translations['select_profession_prompt'] || "To start, please choose your profession from the list below.";
                    addChatMessage(askProfMsg, 'bot', { translationKey: 'select_profession_prompt' });
                    
                    // IMPORTANT FIX: Re-run applyTranslations immediately after adding to ensure the latest language translation is applied.
                    applyTranslations(); 
                    
                    displayProfessionOptions(); 

                    const optionsContainer = chatDisplay.querySelector('.options-container');
                    let optionsText = "";
                    if (optionsContainer) {
                        const optionButtons = optionsContainer.querySelectorAll('.option-btn');
                        optionButtons.forEach((btn, index) => {
                            optionsText += `${index + 1}. ${btn.dataset.text}. `;
                        });
                    }
                    speakText(askProfMsg + " " + optionsText, currentLang);
                 }, 1000);
            }


            // --- Event Listeners ---

            if (createGoalBtn) {
                createGoalBtn.addEventListener('click', startChatSequence);
            }
            
            if (sendBtn) {
                sendBtn.addEventListener('click', handleUserInput);
            }
            
            if (goalInput) {
                goalInput.addEventListener('keypress', (event) => {
                    if (event.key === 'Enter') {
                        handleUserInput(); 
                    }
                });
            }
            
            if (micBtn && SpeechRecognition) {
                 micBtn.addEventListener('click', () => {
                     toggleVoiceRecognition();
                 });
            }
            
            if (ttsBtn) {
                ttsBtn.addEventListener('click', () => {
                    if (isSpeaking) {
                        stopSpeech();
                    } else if (lastSpokenText) {
                        speakText(lastSpokenText, currentLang); 
                    } else {
                        const alertMsg = translations['alert_no_text_spoken'] || "Nothing to read yet. The assistant will read questions as they appear.";
                        showCustomAlert(alertMsg);
                    }
                });
            }
            
            if (langButton && langDropdown) {
                langButton.addEventListener('click', (event) => {
                    event.stopPropagation(); 
                    langDropdown.classList.toggle('show');
                    langButton.setAttribute('aria-expanded', langDropdown.classList.contains('show'));
                });

                window.addEventListener('click', (event) => {
                    if (langDropdown.classList.contains('show') && !langButton.contains(event.target) && !langDropdown.contains(event.target)) {
                        langDropdown.classList.remove('show');
                        langButton.setAttribute('aria-expanded', 'false');
                    }
                });

                langOptions.forEach(option => {
                    option.addEventListener('click', async function(event) {
                        event.preventDefault(); 
                        
                        const selectedLanguageText = this.textContent;
                        const buttonText = selectedLanguageText.split(' ')[0];
                        const newLangCode = this.dataset.lang;
                        
                        if (langButtonText) langButtonText.textContent = buttonText;

                        langOptions.forEach(opt => opt.classList.remove('selected'));
                        this.classList.add('selected');
                        
                        langDropdown.classList.remove('show');
                        langButton.setAttribute('aria-expanded', 'false');

                        if (newLangCode !== currentLang) {
                            currentLang = newLangCode;
                            stopSpeech();
                            await loadTranslations(currentLang); 
                            
                            if (recognition) {
                                const wasRecognizing = isRecognizing;
                                if (wasRecognizing) recognition.stop(); 
                                recognition.lang = langMap[newLangCode] || newLangCode;
                            }
                            
                            showCustomAlert(`${translations['alert_lang_change'] || 'Language set to'} ${selectedLanguageText}`);
                        }
                    });
                });
            }
            
            if (onlineModeBtn) {
                onlineModeBtn.addEventListener('click', switchToOnlineMode);
            }
            
            // ADDED: PDF Download Listener
            if (downloadPdfBtn) {
                downloadPdfBtn.addEventListener('click', downloadResumePdf);
            }
        });
    </script>
</body>
</html>